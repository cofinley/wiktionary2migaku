import re

import wikitextparser as wtp

from language_parsers._language_pair_parser import LanguagePairParser


class French2French(LanguagePairParser):
    """
    French terms from the French wiktionary dump (frwiktionary)
    """
    target_language_code = 'fr'
    word_types = [
        'adjectif',
        'adverbe',
        'adverbe indéfini',
        'adverbe interrogatif',
        'adverbe pronominal',
        'adverbe relatif',
        'conjonction',
        'conjonction de coordination',
        'copule',
        'adjectif démonstratif',
        'déterminant',
        'adjectif exclamatif',
        'adjectif indéfini',
        'adjectif interrogatif',
        'adjectif numéral',
        'adjectif possessif',
        'adjectif relatif',
        'article',
        'article défini',
        'article indéfini',
        'article partitif',
        'nom',
        'nom de famille',
        'patronyme',
        'nom propre',
        'nom scientifique',
        'prénom',
        'préposition',
        'pronom',
        'pronom-adjectif',
        'pronom démonstratif',
        'pronom indéfini',
        'pronom interrogatif',
        'pronom personnel',
        'pronom possessif',
        'pronom relatif',
        'racine',
        'verbe',
        'verbe pronominal',
        'interjection',
        'onomatopée',
        'affixe',
        'circonfixe',
        'infixe',
        'interfixe',
        'particule',
        'particule numérale',
        'postposition',
        'préfixe',
        'radical',
        'suffixe',
        'pré-verbe',
        'pré-nom',
        'enclitique',
        'proclitique',
        'locution',
        'locution-phrase',
        'proverbe',
        'quantificateur',
        'variante typographique',
        'lettre',
        'symbole',
        'classificateur',
        'numéral',
        'sinogramme',
        'gismu',
        'rafsi',
    ]
    grammar_types = [
        "abréviation",
        "ablatif",
        "absolument",
        "abus de langage",
        "accent-renvoi",
        "accusatif",
        "acronyme",
        "adjectif",
        "adverbe",
        "api",
        "alphabet_phonétique_international",
        "anagramme",
        "anaphore",
        "anglicisme",
        "antonyme",
        "aphérèse",
        "apocope",
        "apparenté",
        "archaïque",
        "argot",
        "attestation",
        "auxiliaire",
        "barbarisme",
        "bitransitif",
        "calque",
        "cas régime",
        "cas sujet",
        "causatif",
        "chengyu",
        "circa",
        "classique",
        "collectif",
        "commun",
        "comparatif",
        "conditionnel",
        "contemporain",
        "courant",
        "courant",
        "datif",
        "défectif",
        "dérision",
        "désuet",
        "diacritique|accent",
        "didactique",
        "duel",
        "ellipse",
        "emploi",
        "en particulier",
        "ergatif",
        "épicène",
        "étymologie",
        "euphémisme",
        "familier",
        "féminin",
        "figuré",
        "flexion",
        "formel",
        "futur",
        "génitif",
        "genre",
        "gérondif",
        "hapax",
        "holonyme",
        "homophone",
        "hyperbole",
        "hyperonyme",
        "hyponyme",
        "idiome",
        "imparfait",
        "imperfectif",
        "impersonnel",
        "improprement",
        "indénombrable",
        "informel",
        "instrumental",
        "intransitif",
        "invariable",
        "ironique",
        "irrégulier",
        "lemme",
        "litote",
        "littéraire",
        "locatif",
        "locution",
        "masculin",
        "mécoupure",
        "mélioratif",
        "méronyme",
        "métaphore",
        "métonyme",
        "moderne",
        "mot-valise",
        "néologisme",
        "neutre",
        "neutre",
        "noble",
        "nom",
        "nombre",
        "nominatif",
        "non",
        "objet",
        "objet",
        "obsolète",
        "par_analogie",
        "par_extension",
        "parfait",
        "paronyme",
        "participe passé",
        "participe présent",
        "particulier",
        "passé composé",
        "passé simple",
        "passif",
        "péjoratif",
        "perfectif",
        "pléonasme",
        "plurale_tantum",
        "pluriel",
        "poétique",
        "populaire",
        "préposition",
        "présent",
        "prétérit",
        "pronominal",
        "propre",
        "rare",
        "réciproque",
        "réfléchi",
        "régional",
        "registre_vulgaire",
        "relevé",
        "sic",
        "sigle",
        "singulare_tantum",
        "singulier",
        "solécisme",
        "soutenu",
        "standard",
        "statif",
        "subjonctif",
        "sublime",
        "substantif",
        "substantivation",
        "superlatif",
        "supplétif",
        "synérèse",
        "synonyme",
        "transitif",
        "usage_avéré",
        "usage_critiqué",
        "usage_standard",
        "valence",
        "verbe",
        "vieilli",
        "vieux",
        "vocatif",
        "vulgaire",
        "vulgaire",
        "vulgarité",
        "X-SAMPA",
    ]
    term_pattern = r"(?P<word_template>^=== {{S\|(?P<word_type>" + '|'.join(word_types) + ")\|" + target_language_code + "(?:\||}}).*)(?:.*\n)+?(?P<title_group>^'''.*\n)(?:^[^#].*\n)*(?P<defs>(?:^#.*\n?)*)"


    @staticmethod
    def get_ipa(term_match):
        title_line = term_match['title_group']
        title_line_regex = re.compile(r"^'''(?P<title>.+)(?=''')'''\s?(?:{{pron\|(?P<ipa>[^|]*)\|[^}]+}}(?P<rest>.*))?", re.IGNORECASE)
        match = title_line_regex.search(title_line)
        if match is None:
            return ''
        return match['ipa'] or ''

    @staticmethod
    def get_pos(term_match):
        return term_match['word_type'] or ''

    def get_definitions(self, term_match):
        defs = term_match['defs']
        if defs == '':
            return ''
        definition_regex = re.compile(r"^#\s?(?:{{(?P<grammar>[^|}]+)(?:\|\w+)?}}\s?)?(?P<rest>.*)", re.IGNORECASE | re.MULTILINE)
        definitions = []
        def_list = wtp.parse(defs).get_lists()[0]
        for i, definition in enumerate(def_list.fullitems):
            match = definition_regex.search(definition)
            grammar_type = match['grammar']
            rest = match['rest']
            plain_text = self.parse_text(rest)
            d = str(i+1) + '.'
            if grammar_type and grammar_type.lower() in self.grammar_types:
                d += f' ({grammar_type})'
            d += f' {plain_text}'
            definitions.append(d)
        return '\n'.join(definitions)
